#ifndef LIBCPU_RISCV_DECODE_HH
#define LIBCPU_RISCV_DECODE_HH

#include <climits>
#include <libcpu/riscv_cpu/riscv_cpu.hh>

#define RISCV_INSTR_PAT(pattern, mask, type, operation) \
    if (((instruction^pattern)&mask) == 0) { \
        decode.op = operation; \
        decode.imm = imm_##type<WORD_T>(instruction); \
        decode.rs1 = rs1_##type(instruction);\
        decode.rs2 = rs2_##type(instruction);\
        decode.rd  = rd_##type(instruction);\
        return decode; \
    }

#define RISCV32_INSTR_PAT(pattern, mask, type, operation) \
    if (((instruction^pattern)&mask) == 0) { \
        decode.op = operation; \
        decode.imm = imm_##type<uint32_t>(instruction); \
        decode.rs1 = rs1_##type(instruction);\
        decode.rs2 = rs2_##type(instruction);\
        decode.rd  = rd_##type(instruction);\
        return decode; \
    }

#define RISCV64_INSTR_PAT(pattern, mask, type, operation) \
    if (((instruction^pattern)&mask) == 0) { \
        decode.op = operation; \
        decode.imm = imm_##type<uint64_t>(instruction); \
        decode.rs1 = rs1_##type(instruction);\
        decode.rs2 = rs2_##type(instruction);\
        decode.rd  = rd_##type(instruction);\
        return decode; \
    }

namespace libcpu {

// R-type
template <typename WORD_T>
inline WORD_T       imm_r(uint32_t instr) { return 0; }
inline uint_fast8_t rs1_r(uint32_t instr) { return (instr >> 15) & 0x1F; }
inline uint_fast8_t rs2_r(uint32_t instr) { return (instr >> 20) & 0x1F; }
inline uint_fast8_t rd_r(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

// I-type
template <typename WORD_T>
inline WORD_T       imm_i(uint32_t instr) { return std::make_signed_t<WORD_T>(instr) >> 20; }
inline uint_fast8_t rs1_i(uint32_t instr) { return (instr >> 15) & 0x1F; }
inline uint_fast8_t rs2_i(uint32_t)       { return 0; }
inline uint_fast8_t rd_i(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

// S-type
template <typename WORD_T>
inline WORD_T       imm_s(uint32_t instr) { return (std::make_signed_t<WORD_T>(instr & 0xfe000000) >> 20) | ((instr >> 7) & 0x1f); }
inline uint_fast8_t rs1_s(uint32_t instr) { return (instr >> 15) & 0x1F; }
inline uint_fast8_t rs2_s(uint32_t instr) { return (instr >> 20) & 0x1F; }
inline uint_fast8_t rd_s(uint32_t)        { return 0; }

// B-type
template <typename WORD_T>
inline WORD_T       imm_b(uint32_t instr) { return (std::make_signed_t<WORD_T>(instr & 0x80000000) >> 19) | ((instr & 0x80) << 4) | ((instr >> 20) & 0x7e0) | ((instr >> 7) & 0x1e); }
inline uint_fast8_t rs1_b(uint32_t instr) { return (instr >> 15) & 0x1F; }
inline uint_fast8_t rs2_b(uint32_t instr) { return (instr >> 20) & 0x1F; }
inline uint_fast8_t rd_b(uint32_t)        { return 0; }

// U-type
template <typename WORD_T>
inline WORD_T       imm_u(uint32_t instr) { return std::make_signed_t<WORD_T>(instr&0xfffff000); }
inline uint_fast8_t rs1_u(uint32_t)       { return 0; }
inline uint_fast8_t rs2_u(uint32_t)       { return 0; }
inline uint_fast8_t rd_u(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

// J-type
template <typename WORD_T>
inline WORD_T       imm_j(uint32_t instr) { return (std::make_signed_t<WORD_T>(instr & 0x80000000) >> 11) | (instr & 0xff000) | ((instr >> 9) & 0x800) | ((instr >> 20) & 0x7fe); }
inline uint_fast8_t rs1_j(uint32_t)       { return 0; }
inline uint_fast8_t rs2_j(uint32_t)       { return 0; }
inline uint_fast8_t rd_j(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

template <typename WORD_T>
riscv_cpu<WORD_T>::decode_t riscv_cpu<WORD_T>::decode_instruction(uint32_t instruction) const {
    decode_t decode{nullptr, instruction, 0, 0, 0, 0};

    // U-type instructions
    RISCV_INSTR_PAT(0b00000000000000000000000000110111, 0b00000000000000000000000001111111, u, lui);
    RISCV_INSTR_PAT(0b00000000000000000000000000010111, 0b00000000000000000000000001111111, u, auipc);

    // J-type
    RISCV_INSTR_PAT(0b00000000000000000000000001101111, 0b00000000000000000000000001111111, j, jal);

    // I-type (jalr)
    RISCV_INSTR_PAT(0b00000000000000000000000001100111, 0b00000000000000000111000001111111, i, jalr);

    // B-type
    RISCV_INSTR_PAT(0b00000000000000000000000001100011, 0b00000000000000000111000001111111, b, beq);
    RISCV_INSTR_PAT(0b00000000000000000001000001100011, 0b00000000000000000111000001111111, b, bne);
    RISCV_INSTR_PAT(0b00000000000000000100000001100011, 0b00000000000000000111000001111111, b, blt);
    RISCV_INSTR_PAT(0b00000000000000000101000001100011, 0b00000000000000000111000001111111, b, bge);
    RISCV_INSTR_PAT(0b00000000000000000110000001100011, 0b00000000000000000111000001111111, b, bltu);
    RISCV_INSTR_PAT(0b00000000000000000111000001100011, 0b00000000000000000111000001111111, b, bgeu);

    // Loads (I-type)
    RISCV_INSTR_PAT(0b00000000000000000000000000000011, 0b00000000000000000111000001111111, i, lb);
    RISCV_INSTR_PAT(0b00000000000000000001000000000011, 0b00000000000000000111000001111111, i, lh);
    RISCV_INSTR_PAT(0b00000000000000000010000000000011, 0b00000000000000000111000001111111, i, lw);
    RISCV_INSTR_PAT(0b00000000000000000100000000000011, 0b00000000000000000111000001111111, i, lbu);
    RISCV_INSTR_PAT(0b00000000000000000101000000000011, 0b00000000000000000111000001111111, i, lhu);

    // Stores (S-type)
    RISCV_INSTR_PAT(0b00000000000000000000000000100011, 0b00000000000000000111000001111111, s, sb);
    RISCV_INSTR_PAT(0b00000000000000000001000000100011, 0b00000000000000000111000001111111, s, sh);
    RISCV_INSTR_PAT(0b00000000000000000010000000100011, 0b00000000000000000111000001111111, s, sw);

    // I-type ALU
    RISCV_INSTR_PAT(0b00000000000000000000000000010011, 0b00000000000000000111000001111111, i, addi);
    RISCV_INSTR_PAT(0b00000000000000000010000000010011, 0b00000000000000000111000001111111, i, slti);
    RISCV_INSTR_PAT(0b00000000000000000011000000010011, 0b00000000000000000111000001111111, i, sltiu);
    RISCV_INSTR_PAT(0b00000000000000000100000000010011, 0b00000000000000000111000001111111, i, xori);
    RISCV_INSTR_PAT(0b00000000000000000110000000010011, 0b00000000000000000111000001111111, i, ori);
    RISCV_INSTR_PAT(0b00000000000000000111000000010011, 0b00000000000000000111000001111111, i, andi);
    RISCV_INSTR_PAT(0b00000000000000000001000000010011, 0b11111100000000000111000001111111, i, slli);
    RISCV_INSTR_PAT(0b00000000000000000101000000010011, 0b11111100000000000111000001111111, i, srli);
    RISCV_INSTR_PAT(0b01000000000000000101000000010011, 0b11111100000000000111000001111111, i, srai);

    // R-type
    RISCV_INSTR_PAT(0b00000000000000000000000000110011, 0b11111110000000000111000001111111, r, add);
    RISCV_INSTR_PAT(0b01000000000000000000000000110011, 0b11111110000000000111000001111111, r, sub);
    RISCV_INSTR_PAT(0b00000000000000000001000000110011, 0b11111110000000000111000001111111, r, sll);
    RISCV_INSTR_PAT(0b00000000000000000010000000110011, 0b11111110000000000111000001111111, r, slt);
    RISCV_INSTR_PAT(0b00000000000000000011000000110011, 0b11111110000000000111000001111111, r, sltu);
    RISCV_INSTR_PAT(0b00000000000000000100000000110011, 0b11111110000000000111000001111111, r, xor_);
    RISCV_INSTR_PAT(0b00000000000000000101000000110011, 0b11111110000000000111000001111111, r, srl);
    RISCV_INSTR_PAT(0b01000000000000000101000000110011, 0b11111110000000000111000001111111, r, sra);
    RISCV_INSTR_PAT(0b00000000000000000110000000110011, 0b11111110000000000111000001111111, r, or_);
    RISCV_INSTR_PAT(0b00000000000000000111000000110011, 0b11111110000000000111000001111111, r, and_);

    // M-extension
    RISCV_INSTR_PAT(0b00000010000000000000000000110011, 0b11111110000000000111000001111111, r, mul);
    RISCV_INSTR_PAT(0b00000010000000000001000000110011, 0b11111110000000000111000001111111, r, mulh);
    RISCV_INSTR_PAT(0b00000010000000000010000000110011, 0b11111110000000000111000001111111, r, mulhsu);
    RISCV_INSTR_PAT(0b00000010000000000011000000110011, 0b11111110000000000111000001111111, r, mulhu);
    RISCV_INSTR_PAT(0b00000010000000000100000000110011, 0b11111110000000000111000001111111, r, div);
    RISCV_INSTR_PAT(0b00000010000000000101000000110011, 0b11111110000000000111000001111111, r, divu);
    RISCV_INSTR_PAT(0b00000010000000000110000000110011, 0b11111110000000000111000001111111, r, rem);
    RISCV_INSTR_PAT(0b00000010000000000111000000110011, 0b11111110000000000111000001111111, r, remu);

    // System
    RISCV_INSTR_PAT(0b00000000000000000000000001110011, 0b11111111111111111111111111111111, r, ecall);
    RISCV_INSTR_PAT(0b00000000000100000000000001110011, 0b11111111111111111111111111111111, r, ebreak);

    // CSR operations
    RISCV_INSTR_PAT(0b00000000000000000001000001110011, 0b00000000000000000111000001111111, i, csrrw);
    RISCV_INSTR_PAT(0b00000000000000000010000001110011, 0b00000000000000000111000001111111, i, csrrs);
    RISCV_INSTR_PAT(0b00000000000000000011000001110011, 0b00000000000000000111000001111111, i, csrrc);
    RISCV_INSTR_PAT(0b00000000000000000101000001110011, 0b00000000000000000111000001111111, i, csrrwi);
    RISCV_INSTR_PAT(0b00000000000000000110000001110011, 0b00000000000000000111000001111111, i, csrrsi);
    RISCV_INSTR_PAT(0b00000000000000000111000001110011, 0b00000000000000000111000001111111, i, csrrci);

    if constexpr (sizeof(WORD_T)*CHAR_BIT >= 64) {
    RISCV_INSTR_PAT(0b00000000000000000110000000000011, 0b00000000000000000111000001111111, i, lwu);
    RISCV_INSTR_PAT(0b00000000000000000011000000000011, 0b00000000000000000111000001111111, i, ld);
    RISCV_INSTR_PAT(0b00000000000000000011000000100011, 0b00000000000000000111000001111111, s, sd);
    RISCV_INSTR_PAT(0b00000000000000000000000000011011, 0b00000000000000000111000001111111, i, addiw);
    RISCV_INSTR_PAT(0b00000000000000000001000000011011, 0b11111110000000000111000001111111, i, slliw);
    RISCV_INSTR_PAT(0b00000000000000000101000000011011, 0b11111110000000000111000001111111, i, srliw);
    RISCV_INSTR_PAT(0b01000000000000000101000000011011, 0b11111110000000000111000001111111, i, sraiw);
    RISCV_INSTR_PAT(0b00000000000000000000000000111011, 0b11111110000000000111000001111111, r, addw);
    RISCV_INSTR_PAT(0b01000000000000000000000000111011, 0b11111110000000000111000001111111, r, subw);
    RISCV_INSTR_PAT(0b00000000000000000001000000111011, 0b11111110000000000111000001111111, r, sllw);
    RISCV_INSTR_PAT(0b00000000000000000101000000111011, 0b11111110000000000111000001111111, r, srlw);
    RISCV_INSTR_PAT(0b01000000000000000101000000111011, 0b11111110000000000111000001111111, r, sraw);
    }

    // Default case for invalid instructions
    return decode;
}

}

#endif
