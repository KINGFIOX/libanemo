#include <cstdint>
#include <libcpu/rv32i.hh>
#include <libcpu/rv32i_cpu_nemu.hh>

using namespace libcpu;
using namespace libcpu::rv32i;

#define INSTPAT(pattern, mask, type, operation) \
    if (((instruction^pattern)&mask) == 0) { \
        decode.op = operation; \
        decode.imm = imm_##type(instruction); \
        decode.rs1 = rs1_##type(instruction);\
        decode.rs2 = rs2_##type(instruction);\
        decode.rd  = rd_##type(instruction);\
        return decode; \
    }

// R-type
static inline uint32_t imm_r(uint32_t instr) { return 0; }
static inline uint32_t rs1_r(uint32_t instr) { return (instr >> 15) & 0x1F; }
static inline uint32_t rs2_r(uint32_t instr) { return (instr >> 20) & 0x1F; }
static inline uint32_t rd_r(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

// I-type
static inline uint32_t imm_i(uint32_t instr) { return int32_t(instr) >> 20; }
static inline uint32_t rs1_i(uint32_t instr) { return (instr >> 15) & 0x1F; }
static inline uint32_t rs2_i(uint32_t)       { return 0; }
static inline uint32_t rd_i(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

// S-type
static inline uint32_t imm_s(uint32_t instr) { return (int32_t(instr & 0xfe000000) >> 20) | ((instr >> 7) & 0x1f); }
static inline uint32_t rs1_s(uint32_t instr) { return (instr >> 15) & 0x1F; }
static inline uint32_t rs2_s(uint32_t instr) { return (instr >> 20) & 0x1F; }
static inline uint32_t rd_s(uint32_t)        { return 0; }

// B-type
static inline uint32_t imm_b(uint32_t instr) { return (int32_t(instr & 0x80000000) >> 19) | ((instr & 0x80) << 4) | ((instr >> 20) & 0x7e0) | ((instr >> 7) & 0x1e); }
static inline uint32_t rs1_b(uint32_t instr) { return (instr >> 15) & 0x1F; }
static inline uint32_t rs2_b(uint32_t instr) { return (instr >> 20) & 0x1F; }
static inline uint32_t rd_b(uint32_t)        { return 0; }

// U-type
static inline uint32_t imm_u(uint32_t instr) { return instr & 0xfffff000; }
static inline uint32_t rs1_u(uint32_t)       { return 0; }
static inline uint32_t rs2_u(uint32_t)       { return 0; }
static inline uint32_t rd_u(uint32_t instr)  { return (instr >> 7)  & 0x1F; }

// J-type
static inline uint32_t imm_j(uint32_t instr) { return (int32_t(instr & 0x80000000) >> 11) | (instr & 0xff000) | ((instr >> 9) & 0x800) | ((instr >> 20) & 0x7fe); }
static inline uint32_t rs1_j(uint32_t)       { return 0; }
static inline uint32_t rs2_j(uint32_t)       { return 0; }
static inline uint32_t rd_j(uint32_t instr)  { return (instr >> 7)  & 0x1F; }


rv32i_cpu_nemu::decode_t rv32i_cpu_nemu::decode_instruction(uint32_t instruction) {
    decode_t decode{.imm=0, .rd=0};
    decode.instr = instruction;

    // U-type instructions
    INSTPAT(0b00000000000000000000000000110111, 0b00000000000000000000000001111111, u, lui);
    INSTPAT(0b00000000000000000000000000010111, 0b00000000000000000000000001111111, u, auipc);

    // J-type
    INSTPAT(0b00000000000000000000000001101111, 0b00000000000000000000000001111111, j, jal);

    // I-type (jalr)
    INSTPAT(0b00000000000000000000000001100111, 0b00000000000000000111000001111111, i, jalr);

    // B-type
    INSTPAT(0b00000000000000000000000001100011, 0b00000000000000000111000001111111, b, beq);
    INSTPAT(0b00000000000000000001000001100011, 0b00000000000000000111000001111111, b, bne);
    INSTPAT(0b00000000000000000100000001100011, 0b00000000000000000111000001111111, b, blt);
    INSTPAT(0b00000000000000000101000001100011, 0b00000000000000000111000001111111, b, bge);
    INSTPAT(0b00000000000000000110000001100011, 0b00000000000000000111000001111111, b, bltu);
    INSTPAT(0b00000000000000000111000001100011, 0b00000000000000000111000001111111, b, bgeu);

    // Loads (I-type)
    INSTPAT(0b00000000000000000000000000000011, 0b00000000000000000111000001111111, i, lb);
    INSTPAT(0b00000000000000000001000000000011, 0b00000000000000000111000001111111, i, lh);
    INSTPAT(0b00000000000000000010000000000011, 0b00000000000000000111000001111111, i, lw);
    INSTPAT(0b00000000000000000100000000000011, 0b00000000000000000111000001111111, i, lbu);
    INSTPAT(0b00000000000000000101000000000011, 0b00000000000000000111000001111111, i, lhu);

    // Stores (S-type)
    INSTPAT(0b00000000000000000000000000100011, 0b00000000000000000111000001111111, s, sb);
    INSTPAT(0b00000000000000000001000000100011, 0b00000000000000000111000001111111, s, sh);
    INSTPAT(0b00000000000000000010000000100011, 0b00000000000000000111000001111111, s, sw);

    // I-type ALU
    INSTPAT(0b00000000000000000000000000010011, 0b00000000000000000111000001111111, i, addi);
    INSTPAT(0b00000000000000000010000000010011, 0b00000000000000000111000001111111, i, slti);
    INSTPAT(0b00000000000000000011000000010011, 0b00000000000000000111000001111111, i, sltiu);
    INSTPAT(0b00000000000000000100000000010011, 0b00000000000000000111000001111111, i, xori);
    INSTPAT(0b00000000000000000110000000010011, 0b00000000000000000111000001111111, i, ori);
    INSTPAT(0b00000000000000000111000000010011, 0b00000000000000000111000001111111, i, andi);
    INSTPAT(0b00000000000000000001000000010011, 0b11111110000000000111000001111111, i, slli);
    INSTPAT(0b00000000000000000101000000010011, 0b11111110000000000111000001111111, i, srli);
    INSTPAT(0b01000000000000000101000000010011, 0b11111110000000000111000001111111, i, srai);

    // R-type
    INSTPAT(0b00000000000000000000000000110011, 0b11111110000000000111000001111111, r, add);
    INSTPAT(0b01000000000000000000000000110011, 0b11111110000000000111000001111111, r, sub);
    INSTPAT(0b00000000000000000001000000110011, 0b11111110000000000111000001111111, r, sll);
    INSTPAT(0b00000000000000000010000000110011, 0b11111110000000000111000001111111, r, slt);
    INSTPAT(0b00000000000000000011000000110011, 0b11111110000000000111000001111111, r, sltu);
    INSTPAT(0b00000000000000000100000000110011, 0b11111110000000000111000001111111, r, xor_);
    INSTPAT(0b00000000000000000101000000110011, 0b11111110000000000111000001111111, r, srl);
    INSTPAT(0b01000000000000000101000000110011, 0b11111110000000000111000001111111, r, sra);
    INSTPAT(0b00000000000000000110000000110011, 0b11111110000000000111000001111111, r, or_);
    INSTPAT(0b00000000000000000111000000110011, 0b11111110000000000111000001111111, r, and_);

    // M-extension
    INSTPAT(0b00000010000000000000000000110011, 0b11111110000000000111000001111111, r, mul);
    INSTPAT(0b00000010000000000001000000110011, 0b11111110000000000111000001111111, r, mulh);
    INSTPAT(0b00000010000000000010000000110011, 0b11111110000000000111000001111111, r, mulhsu);
    INSTPAT(0b00000010000000000011000000110011, 0b11111110000000000111000001111111, r, mulhu);
    INSTPAT(0b00000010000000000100000000110011, 0b11111110000000000111000001111111, r, div);
    INSTPAT(0b00000010000000000101000000110011, 0b11111110000000000111000001111111, r, divu);
    INSTPAT(0b00000010000000000110000000110011, 0b11111110000000000111000001111111, r, rem);
    INSTPAT(0b00000010000000000111000000110011, 0b11111110000000000111000001111111, r, remu);

    // CSR operations
    INSTPAT(0b00000000000000000001000001110011, 0b00000000000000000111000001111111, i, csrrw);
    INSTPAT(0b00000000000000000010000001110011, 0b00000000000000000111000001111111, i, csrrs);
    INSTPAT(0b00000000000000000011000001110011, 0b00000000000000000111000001111111, i, csrrc);
    INSTPAT(0b00000000000000000101000001110011, 0b00000000000000000111000001111111, i, csrrwi);
    INSTPAT(0b00000000000000000110000001110011, 0b00000000000000000111000001111111, i, csrrsi);
    INSTPAT(0b00000000000000000111000001110011, 0b00000000000000000111000001111111, i, csrrci);

    // Environment calls
    INSTPAT(0b00000000000000000000000001110011, 0b11111111111111111111111111111111, r, ecall);
    INSTPAT(0b00110000001000000000000001110011, 0b11111111111111111111111111111111, r, mret);
    INSTPAT(0b00000000000100000000000001110011, 0b11111111111111111111111111111111, r, ebreak);

    // Default case for invalid instructions
    decode.op = nullptr;
    return decode;
}
